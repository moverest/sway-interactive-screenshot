#!/usr/bin/env python3

import abc
import argparse
import os
import json
import subprocess
from datetime import datetime
from typing import (
    Any,
    Dict,
    Iterable,
    Iterator,
    List,
    NamedTuple,
    Union,
    Optional,
    Tuple,
)
from pathlib import Path


class CanceledError(Exception):
    def __init__(self, msg: str) -> None:
        super().__init__(msg)
        self.msg = msg


class Window(NamedTuple):
    name: str
    x: int
    y: int
    width: int
    height: int
    focused: bool

    def __str__(self) -> str:
        return f"window: {self.name}"

    def get_geometry_str(self) -> str:
        return f"{self.x},{self.y} {self.width}x{self.height}"

    def capture(self, *, filepath: str) -> None:
        capture(filepath=filepath, geometry=self.get_geometry_str())


class AllOutputs:
    selection_name = "all-outputs"

    def __str__(self) -> str:
        return "all outputs"

    def capture(self, *, filepath: str) -> None:
        capture(filepath=filepath)


class Region:
    selection_name = "region"

    def __str__(self) -> str:
        return "region"

    def capture(self, *, filepath: str) -> None:
        geometry = ask_geometry()
        if geometry is None:
            raise CanceledError("No region selected.")

        capture(filepath=filepath, geometry=geometry)


class FocusedWindow:
    selection_name = "focused-window"

    def __str__(self) -> str:
        return "focused window"

    def capture(self, *, filepath: str) -> None:
        window = next(
            (window for window in get_windows() if window.focused),
            None,
        )
        if window is None:
            raise CanceledError("Could not find any focused window.")

        window.capture(filepath=filepath)


class SelectWindow:
    selection_name = "select-window"

    def __str__(self) -> str:
        return "select window"

    def capture(self, *, filepath: str) -> None:
        windows = list(get_windows())
        if not windows:
            raise CanceledError("No visible window found.")

        geometry = ask_geometry(window.get_geometry_str() for window in windows)
        if geometry is None:
            raise CanceledError("No window selected.")
        capture(filepath=filepath, geometry=geometry)


class FocusedOutput:
    selection_name = "focused-output"

    def __str__(self) -> str:
        return "focused output"

    def capture(self, *, filepath: str) -> None:
        output = next(
            (output for output in get_windows() if output.focused),
            None,
        )
        if output is None:
            raise CanceledError("Could not find any focused output.")

        output.capture(filepath=filepath)


class Output(NamedTuple):
    name: str
    model: Optional[str]
    focused: bool

    def __str__(self) -> str:
        model = f" ({self.model})" if self.model else ""
        focused = " (focused)" if self.focused else ""
        return f"output: {self.name}{model}{focused}"

    def capture(self, *, filepath: str) -> None:
        capture(filepath=filepath, output=self.name)


class SelectOutput:
    selection_name = "select-output"

    def __str__(self) -> str:
        return "select output"

    def capture(self, *, filepath: str) -> None:
        output = ask_output()
        if output is None:
            raise CanceledError("No output selected.")

        capture(filepath=filepath, output=output)


def get_windows() -> Iterator[Window]:
    def walk(node: Dict[str, Any]) -> Iterator[Window]:
        sub_nodes = node.get("nodes")
        if sub_nodes:
            for sub_node in sub_nodes:
                yield from walk(sub_node)
        elif node.get("visible") and node.get("pid"):
            rect = node["rect"]
            yield Window(
                name=node["name"],
                x=rect["x"],
                y=rect["y"],
                width=rect["width"],
                height=rect["height"],
                focused=node["focused"],
            )

    process = subprocess.run(
        ["swaymsg", "-t", "get_tree"],
        capture_output=True,
        check=True,
    )
    tree = json.loads(process.stdout.decode())
    return walk(tree)


def get_outputs() -> Iterator[Output]:
    process = subprocess.run(
        ["swaymsg", "-t", "get_outputs"],
        capture_output=True,
        check=True,
    )
    for output in json.loads(process.stdout.decode()):
        yield Output(
            name=output["name"],
            model=output["model"],
            focused=output["focused"],
        )


def ask(
    choices: List[Any],
    *,
    prompt: Optional[str] = None,
    lines: Optional[int] = None,
    index: bool = False,
) -> Union[int, str, None]:
    args = ["fuzzel", "--dmenu"]

    if index:
        args.append("--index")

    if prompt is not None:
        args.extend(("--prompt", prompt))

    if lines is not None:
        args.extend(("--lines", str(lines)))

    process = subprocess.run(
        args,
        input=b"\n".join(str(choice).encode() for choice in choices),
        capture_output=True,
        check=False,
    )

    if process.returncode != 0:
        return None

    stdout = process.stdout.decode()

    return int(stdout) if index else stdout.strip()


def notify(
    title: str,
    summary: Optional[str] = None,
    *,
    icon: Optional[str] = None,
    actions: List[Tuple[str, str]] = None,
) -> Optional[str]:
    args = ["notify-send"]

    if icon is not None:
        args.extend(("--icon", icon))

    for action_name, action_desc in actions or ():
        args.extend(("-A", f"{action_name}={action_desc}"))

    args.extend(("--", title))
    if summary:
        args.append(summary)

    process = subprocess.run(args, capture_output=True, check=True)
    return process.stdout.decode().strip() or None


def capture(
    *,
    filepath: str,
    geometry: Optional[str] = None,
    output: Optional[str] = None,
) -> None:
    args = ["grim"]

    if geometry is not None:
        args.extend(("-g", geometry))

    if output is not None:
        args.extend(("-o", output))

    args.append(filepath)
    subprocess.run(args, check=True)


def ask_geometry(geometries: Optional[Iterable[str]] = None) -> Optional[str]:
    if geometries is not None:
        geomerties_input = b"\n".join(geometry.encode() for geometry in geometries)
    else:
        geomerties_input = None

    process = subprocess.run(
        ["slurp"],
        capture_output=True,
        input=geomerties_input,
        check=False,
    )
    if process.returncode != 0:
        return None

    return process.stdout.decode().strip()


def ask_output() -> Optional[str]:
    process = subprocess.run(
        ["slurp", "-o", "-f", "%o"], capture_output=True, check=False
    )
    if process.returncode != 0:
        return None

    return process.stdout.decode().strip()


def edit_capture(filepath: str) -> None:
    subprocess.run(["swappy", "-f", filepath, "-o", filepath], check=False)


def copy_file_to_clipboard(filepath: str) -> None:
    with open(filepath, "rb") as file:
        with subprocess.Popen("wl-copy", stdin=file) as process:
            process.wait()


class NotificationAction(abc.ABC):
    name: str
    description: str

    @classmethod
    @abc.abstractmethod
    def run(cls, *, filepath: Path) -> None:
        pass


class EditNotificationAction(NotificationAction):
    name = "default"
    description = "Edit screenshot"

    @classmethod
    def run(cls, *, filepath: Path) -> None:
        filepath_str = str(filepath.expanduser())
        edit_capture(filepath_str)
        copy_file_to_clipboard(filepath_str)


class DeleteNotificationAction(NotificationAction):
    name = "delete"
    description = "Delete screenshot"

    @classmethod
    def run(cls, *, filepath: Path) -> None:
        filepath.expanduser().unlink()
        notify("Screenshot deleted")


class DragonNotificationAction(NotificationAction):
    name = "dragon"
    description = "Drag and drop screenshot"

    @classmethod
    def run(cls, *, filepath: Path) -> None:
        subprocess.run(["dragon-drop", filepath.expanduser()], check=False)


class OpenNotificationAction(NotificationAction):
    name = "open"
    description = "Open screenshot"

    @classmethod
    def run(cls, *, filepath: Path) -> None:
        subprocess.run(["xdg-open", filepath.expanduser()], check=False)


NOTIFICATION_ACTIONS = {
    action.name: action
    for action in (
        EditNotificationAction,
        DeleteNotificationAction,
        DragonNotificationAction,
        OpenNotificationAction,
    )
}


def parse_arguments():
    argparser = argparse.ArgumentParser(
        prog="sway-interactive-screenshot",
        description="Interactively take screenshots with Sway.",
    )
    selections = (
        Region,
        FocusedOutput,
        AllOutputs,
        SelectOutput,
        FocusedWindow,
        SelectWindow,
    )
    argparser.add_argument(
        "-s",
        "--selection",
        choices=[selection.selection_name for selection in selections],
        help="Selection mode.",
    )
    argparser.add_argument(
        "--save-dir",
        help="Directory where screenshots are saved.",
    )
    argparser.add_argument(
        "-o",
        "--output",
        help="Output file name. If set, --save-dir is ignored.",
    )

    args = argparser.parse_args()
    if args.selection is not None:
        args.selection = next(
            (
                selection
                for selection in selections
                if selection.selection_name == args.selection
            ),
            None,
        )
    return args


def main():
    args = parse_arguments()
    save_dir = (
        Path(args.save_dir)
        if args.save_dir is not None
        else Path(os.getenv("SWAY_INTERACTIVE_SCREENSHOT_SAVEDIR", "~"))
    )
    save_dir.expanduser().mkdir(parents=True, exist_ok=True)
    filepath = Path(args.output) if args.output else None

    try:
        if args.selection is None:
            choices = [
                Region(),
                FocusedOutput(),
                AllOutputs(),
                SelectOutput(),
                *get_outputs(),
                FocusedWindow(),
                SelectWindow(),
                *get_windows(),
            ]

            choice_idx = ask(choices, prompt="ðŸ“·> ", index=True)
            if choice_idx is None:
                return
            if choice_idx == -1:
                raise CanceledError("No option selected.")

            choice = choices[choice_idx]
        else:
            choice = args.selection()

        if not filepath:
            time_str = datetime.now().strftime("%Y-%m-%dT%H:%M:%S")
            filepath = save_dir / f"screenshot_{time_str}.png"

        choice.capture(filepath=filepath.expanduser())
        copy_file_to_clipboard(filepath.expanduser())

        action_name = notify(
            "Screenshot",
            summary=f"File saved as <i>{filepath}</i>.",
            icon=filepath.expanduser(),
            actions=[
                (action.name, action.description)
                for action in NOTIFICATION_ACTIONS.values()
            ],
        )
        action = NOTIFICATION_ACTIONS.get(action_name)
        if action is not None:
            action.run(filepath=filepath)

    except Exception as err:  # pylint: disable=broad-except
        if isinstance(err, CanceledError):
            notify("Screenshot canceled", summary=err.msg)
        else:
            notify("Screenshot error")
            raise


if __name__ == "__main__":
    main()
