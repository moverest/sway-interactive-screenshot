#!/usr/bin/env python3

import abc
import argparse
import os
import json
import signal
import sys
import subprocess
from datetime import datetime
from typing import (
    Any,
    Dict,
    Iterable,
    Iterator,
    List,
    NamedTuple,
    Union,
    Optional,
    Tuple,
    Type,
)
from pathlib import Path


class CanceledError(Exception):
    def __init__(self, msg: Optional[str] = None) -> None:
        super().__init__(msg)
        self.msg = msg


class Area(NamedTuple):
    output: Optional[str] = None
    geometry: Optional[str] = None


class Window(NamedTuple):
    name: str
    x: int
    y: int
    width: int
    height: int
    focused: bool

    def __str__(self) -> str:
        return f"window: {self.name}"

    def get_geometry_str(self) -> str:
        return f"{self.x},{self.y} {self.width}x{self.height}"

    def get_area(self) -> Area:
        return Area(geometry=self.get_geometry_str())


class AllOutputs:
    selection_name = "all-outputs"

    def __str__(self) -> str:
        return "all outputs"

    def get_area(self) -> Area:
        return Area()


class Region:
    selection_name = "region"

    def __str__(self) -> str:
        return "region"

    def get_area(self) -> Area:
        geometry = ask_geometry()
        if geometry is None:
            raise CanceledError("No region selected.")

        return Area(geometry=geometry)


class FocusedWindow:
    selection_name = "focused-window"

    def __str__(self) -> str:
        return "focused window"

    def get_area(self) -> Area:
        window = next(
            (window for window in get_windows() if window.focused),
            None,
        )
        if window is None:
            raise CanceledError("Could not find any focused window.")

        return window.get_area()


class SelectWindow:
    selection_name = "select-window"

    def __str__(self) -> str:
        return "select window"

    def get_area(self) -> Area:
        windows = list(get_windows())
        if not windows:
            raise CanceledError("No visible window found.")

        geometry = ask_geometry(window.get_geometry_str() for window in windows)
        if geometry is None:
            raise CanceledError("No window selected.")

        return Area(geometry=geometry)


class FocusedOutput:
    selection_name = "focused-output"

    def __str__(self) -> str:
        return "focused output"

    def get_area(self) -> Area:
        output = next(
            (output for output in get_outputs() if output.focused),
            None,
        )
        if output is None:
            raise CanceledError("Could not find any focused output.")

        return output.get_area()


class Output(NamedTuple):
    name: str
    model: Optional[str]
    focused: bool

    def __str__(self) -> str:
        model = f" ({self.model})" if self.model else ""
        focused = " (focused)" if self.focused else ""
        return f"output: {self.name}{model}{focused}"

    def get_area(self) -> Area:
        return Area(output=self.name)


class SelectOutput:
    selection_name = "select-output"

    def __str__(self) -> str:
        return "select output"

    def get_area(self) -> Area:
        output = ask_output()
        if output is None:
            raise CanceledError("No output selected.")

        return Area(output=output)


def get_windows() -> Iterator[Window]:
    def walk(node: Dict[str, Any]) -> Iterator[Window]:
        sub_nodes = node.get("floating_nodes")
        if sub_nodes:
            for sub_node in sub_nodes:
                yield from walk(sub_node)
        sub_nodes = node.get("nodes")
        if sub_nodes:
            for sub_node in sub_nodes:
                yield from walk(sub_node)
        elif node.get("visible") and node.get("pid"):
            rect = node["rect"]
            yield Window(
                name=node["name"],
                x=rect["x"],
                y=rect["y"],
                width=rect["width"],
                height=rect["height"],
                focused=node["focused"],
            )

    process = subprocess.run(
        ["swaymsg", "-t", "get_tree"],
        capture_output=True,
        check=True,
    )
    tree = json.loads(process.stdout.decode())
    return walk(tree)


def get_outputs() -> Iterator[Output]:
    process = subprocess.run(
        ["swaymsg", "-t", "get_outputs"],
        capture_output=True,
        check=True,
    )
    for output in json.loads(process.stdout.decode()):
        yield Output(
            name=output["name"],
            model=output["model"],
            focused=output["focused"],
        )


def ask(
    choices: List[Any],
    *,
    prompt: Optional[str] = None,
    lines: Optional[int] = None,
    index: bool = False,
) -> Union[int, str, None]:
    args = ["fuzzel", "--dmenu"]

    if index:
        args.append("--index")

    if prompt is not None:
        args.extend(("--prompt", prompt))

    if lines is not None:
        args.extend(("--lines", str(lines)))

    process = subprocess.run(
        args,
        input=b"\n".join(str(choice).encode() for choice in choices),
        capture_output=True,
        check=False,
    )

    if process.returncode != 0:
        return None

    stdout = process.stdout.decode()

    return int(stdout) if index else stdout.strip()


def notify(
    title: str,
    summary: Optional[str] = None,
    *,
    icon: Optional[str] = None,
    actions: List[Tuple[str, str]] = None,
) -> Optional[str]:
    args = ["notify-send"]

    if icon is not None:
        args.extend(("--icon", icon))

    for action_name, action_desc in actions or ():
        args.extend(("-A", f"{action_name}={action_desc}"))

    args.extend(("--", title))
    if summary:
        args.append(summary)

    process = subprocess.run(args, capture_output=True, check=True)
    return process.stdout.decode().strip() or None


def capture(
    *,
    filepath: str,
    geometry: Optional[str] = None,
    output: Optional[str] = None,
) -> None:
    args = ["grim"]

    if geometry is not None:
        args.extend(("-g", geometry))

    if output is not None:
        args.extend(("-o", output))

    args.append(filepath)
    subprocess.run(args, check=True)


def video_capture(
    *,
    filepath: str,
    geometry: Optional[str] = None,
    output: Optional[str] = None,
    audio: Union[bool, str, None] = None,
    pid_file: Optional[Path] = None,
) -> None:
    args = ["wf-recorder", "-f", filepath]

    if geometry is not None:
        args.extend(("-g", geometry))

    if output is not None:
        args.extend(("-o", output))

    if audio is not None:
        if audio is True:
            args.append("-a")
        else:
            args.extend(("-a", str(audio)))

    with subprocess.Popen(args) as process:
        try:
            if pid_file:
                pid_file.write_text(str(process.pid))
            process.wait()
            if process.returncode != 0:
                raise Exception(
                    f"wf-recorder exited with status code {process.returncode}"
                )
        finally:
            if pid_file:
                pid_file.unlink(missing_ok=True)


def ask_geometry(geometries: Optional[Iterable[str]] = None) -> Optional[str]:
    if geometries is not None:
        geomerties_input = b"\n".join(geometry.encode() for geometry in geometries)
    else:
        geomerties_input = None

    process = subprocess.run(
        ["slurp"],
        capture_output=True,
        input=geomerties_input,
        check=False,
    )
    if process.returncode != 0:
        return None

    return process.stdout.decode().strip()


def ask_output() -> Optional[str]:
    process = subprocess.run(
        ["slurp", "-o", "-f", "%o"], capture_output=True, check=False
    )
    if process.returncode != 0:
        return None

    return process.stdout.decode().strip()


def edit_capture(filepath: str) -> None:
    subprocess.run(["swappy", "-f", filepath, "-o", filepath], check=False)


def copy_file_to_clipboard(filepath: str) -> None:
    with open(filepath, "rb") as file:
        with subprocess.Popen("wl-copy", stdin=file) as process:
            process.wait()


class NotificationAction(abc.ABC):
    name: str
    description: str

    @classmethod
    @abc.abstractmethod
    def run(cls, *, filepath: Path) -> None:
        pass


class EditNotificationAction(NotificationAction):
    name = "default"
    description = "Edit"

    @classmethod
    def run(cls, *, filepath: Path) -> None:
        filepath_str = str(filepath.expanduser())
        edit_capture(filepath_str)
        copy_file_to_clipboard(filepath_str)


class DeleteNotificationAction(NotificationAction):
    name = "delete"
    description = "Delete"

    @classmethod
    def run(cls, *, filepath: Path) -> None:
        filepath.expanduser().unlink()
        notify("Deleted")


class DragonNotificationAction(NotificationAction):
    name = "dragon"
    description = "Drag and drop"

    @classmethod
    def run(cls, *, filepath: Path) -> None:
        subprocess.run(["dragon-drop", filepath.expanduser()], check=False)


class OpenNotificationAction(NotificationAction):
    name = "open"
    description = "Open"

    @classmethod
    def run(cls, *, filepath: Path) -> None:
        subprocess.run(["xdg-open", filepath.expanduser()], check=False)


def parse_arguments():
    argparser = argparse.ArgumentParser(
        prog="sway-interactive-screenshot",
        description="Interactively take screenshots with Sway.",
    )
    selections = (
        Region,
        FocusedOutput,
        AllOutputs,
        SelectOutput,
        FocusedWindow,
        SelectWindow,
    )
    argparser.add_argument(
        "-s",
        "--selection",
        choices=[selection.selection_name for selection in selections],
        help="Selection mode.",
    )
    argparser.add_argument(
        "--save-dir",
        help="Directory where screenshots are saved.",
    )
    argparser.add_argument(
        "-o",
        "--output",
        help="Output file name. If set, --save-dir is ignored.",
    )
    argparser.add_argument(
        "--video",
        help="Make a screen video recording.",
        action="store_true",
    )

    args = argparser.parse_args()
    if args.selection is not None:
        args.selection = next(
            (
                selection
                for selection in selections
                if selection.selection_name == args.selection
            ),
            None,
        )
    return args


class CaptureMode(abc.ABC):
    @abc.abstractmethod
    def get_prompt(self) -> str:
        pass

    @abc.abstractmethod
    def get_filename(self) -> str:
        pass

    @abc.abstractmethod
    def get_display_name(self) -> str:
        pass

    def early_exit(self) -> bool:
        return False

    @abc.abstractmethod
    def capture(self, *, area: Area, filepath: str) -> None:
        pass

    @abc.abstractmethod
    def get_notification_actions(self) -> Iterable[Type[NotificationAction]]:
        pass

    def get_notification_icon(self, filepath: str) -> Optional[str]:
        return None


class Screenshot(CaptureMode):
    def get_prompt(self) -> str:
        return "ðŸ“·> "

    def get_filename(self) -> str:
        return datetime.now().strftime("screenshot_%Y-%m-%dT%H:%M:%S.png")

    def get_display_name(self) -> str:
        return "Screenshot"

    def capture(self, *, area: Area, filepath: str) -> None:
        capture(
            filepath=filepath,
            geometry=area.geometry,
            output=area.output,
        )
        copy_file_to_clipboard(filepath)

    def get_notification_actions(self) -> Iterable[Type[NotificationAction]]:
        return (
            EditNotificationAction,
            DeleteNotificationAction,
            DragonNotificationAction,
            OpenNotificationAction,
        )

    def get_notification_icon(self, filepath: str) -> Optional[str]:
        return filepath


class VideoCapture(CaptureMode):
    def get_prompt(self) -> str:
        return "ðŸ“¹> "

    def get_filename(self) -> str:
        return datetime.now().strftime("video_capture_%Y-%m-%dT%H:%M:%S.mkv")

    def get_display_name(self) -> str:
        return "Video capture"

    def get_pid_filepath(self) -> Path:
        xdg_runtime_dir = os.getenv("XDG_RUNTIME_DIR")
        if xdg_runtime_dir is None:
            xdg_runtime_dir = f"/run/user/{os.getuid()}"

        wayland_display = os.getenv("WAYLAND_DISPLAY", "wayland-1")

        return (
            Path(xdg_runtime_dir)
            / f"sway-interactive-screenshot.{wayland_display}.video.pid"
        )

    def early_exit(self) -> bool:
        pid_filepath = self.get_pid_filepath()
        if pid_filepath.exists():
            pid = int(pid_filepath.read_text())
            print(
                f"Sending kill signal to {pid} to stop video recording.",
                file=sys.stderr,
            )
            os.kill(pid, signal.SIGINT)
            notify(self.get_display_name(), "Stopping recording.")
            return True

        return False

    def capture(self, *, area: Area, filepath: str) -> None:
        audio_raw_input = ask(["yes", "no"], prompt=self.get_prompt() + "Audio? ")
        if audio_raw_input is None:
            raise CanceledError("No audio preference selected.")

        start_recording = ask(
            ["yes", "cancel"], prompt=self.get_prompt() + "Start recording? "
        )
        if start_recording != "yes":
            raise CanceledError()

        video_capture(
            filepath=filepath,
            geometry=area.geometry,
            output=area.output,
            audio=audio_raw_input == "yes",
            pid_file=self.get_pid_filepath(),
        )

    def get_notification_actions(self) -> Iterable[Type[NotificationAction]]:
        return (
            DeleteNotificationAction,
            DragonNotificationAction,
            OpenNotificationAction,
        )


def main():
    args = parse_arguments()
    save_dir = (
        Path(args.save_dir)
        if args.save_dir is not None
        else Path(os.getenv("SWAY_INTERACTIVE_SCREENSHOT_SAVEDIR", "~"))
    )
    save_dir.expanduser().mkdir(parents=True, exist_ok=True)
    filepath = Path(args.output) if args.output else None
    mode: CaptureMode = Screenshot() if not args.video else VideoCapture()
    if mode.early_exit():
        return

    try:
        if args.selection is None:
            choices = [
                Region(),
                FocusedOutput(),
                *((AllOutputs(),) if isinstance(mode, Screenshot) else ()),
                SelectOutput(),
                *get_outputs(),
                FocusedWindow(),
                SelectWindow(),
                *get_windows(),
            ]

            choice_idx = ask(choices, prompt=mode.get_prompt(), index=True)
            if choice_idx is None:
                return
            if choice_idx == -1:
                raise CanceledError("No option selected.")

            choice = choices[choice_idx]
        else:
            choice = args.selection()

        area = choice.get_area()
        if not filepath:
            filepath = save_dir / mode.get_filename()

        mode.capture(filepath=filepath.expanduser(), area=area)

        action_name = notify(
            mode.get_display_name(),
            summary=f"File saved as <i>{filepath}</i>.",
            icon=mode.get_notification_icon(filepath.expanduser()),
            actions=[
                (action.name, action.description)
                for action in mode.get_notification_actions()
            ],
        )
        action = next(
            (
                action
                for action in mode.get_notification_actions()
                if action.name == action_name
            ),
            None,
        )

        if action is not None:
            action.run(filepath=filepath)

    except Exception as err:  # pylint: disable=broad-except
        if isinstance(err, CanceledError):
            notify(f"{mode.get_display_name()} canceled", summary=err.msg)
        else:
            notify(f"{mode.get_display_name()} error", str(err))
            raise


if __name__ == "__main__":
    main()
